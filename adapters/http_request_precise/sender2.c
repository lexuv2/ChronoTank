// code generated by AI, later will modify it.
// Just POC

// To compile:
// gcc -o sender2 sender2.c
//
// To run:
// ./sender2 <server_ip> <server_port> "<http_request_body>"
// Example:
// ./sender2 192.168.1.1 80 "GET / HTTP/1.1\r\nHost: example.com\r\nConnection: close\r\n\r\n"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <time.h>
#include <unistd.h>
#include <linux/errqueue.h>
#include <linux/net_tstamp.h>
#include <errno.h>

void exit_error(const char *msg) {
    perror(msg);
    exit(EXIT_FAILURE);
}

double timespec_diff(struct timespec *start, struct timespec *end) {
    long sec = end->tv_sec - start->tv_sec;
    long nsec = end->tv_nsec - start->tv_nsec;
    if (nsec < 0) {
        sec--;
        nsec += 1000000000;
    }
    return sec + nsec / 1e9;
}

int main(int argc, char *argv[]) {
    if (argc != 4) {
        fprintf(stderr, "Usage: %s <server_ip> <server_port> \"<http_request_body>\"\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    const char *server_ip = argv[1];
    int server_port = atoi(argv[2]);
    const char *http_request = argv[3];

    if (server_port <= 0 || server_port > 65535) {
        fprintf(stderr, "Invalid port number: %d\n", server_port);
        exit(EXIT_FAILURE);
    }

    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0)
        exit_error("socket");

    // Enable timestamping
    int flags = SOF_TIMESTAMPING_TX_SOFTWARE | 
                SOF_TIMESTAMPING_RX_SOFTWARE |
                SOF_TIMESTAMPING_SOFTWARE;
    if (setsockopt(sockfd, SOL_SOCKET, SO_TIMESTAMPING, &flags, sizeof(flags)))
        exit_error("setsockopt");

    struct sockaddr_in server_addr = {
        .sin_family = AF_INET,
        .sin_port = htons(server_port)
    };
    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0)
        exit_error("inet_pton");

    if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)))
        exit_error("connect");

    // Send HTTP request
    ssize_t sent = send(sockfd, http_request, strlen(http_request), 0);
    if (sent != strlen(http_request))
        exit_error("send");

    // Get TX timestamp from error queue
    struct msghdr msg = {0};
    struct iovec iov;
    char buf[512];
    char ctrl_buf[1024];
    struct timespec tx_time;

    iov.iov_base = buf;
    iov.iov_len = sizeof(buf);
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;
    msg.msg_control = ctrl_buf;
    msg.msg_controllen = sizeof(ctrl_buf);

    ssize_t n = recvmsg(sockfd, &msg, MSG_ERRQUEUE);
    if (n < 0)
        exit_error("recvmsg (tx)");

    // Extract TX timestamp
    struct cmsghdr *cmsg;
    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
        if (cmsg->cmsg_level == SOL_SOCKET && 
            cmsg->cmsg_type == SCM_TIMESTAMPING) {
            struct timespec *times = (struct timespec *)CMSG_DATA(cmsg);
            tx_time = times[0]; // Use software timestamp
            break;
        }
    }

    // Receive response and get RX timestamp
    struct timespec rx_time;
    memset(&msg, 0, sizeof(msg));
    iov.iov_base = buf;
    iov.iov_len = sizeof(buf);
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;
    msg.msg_control = ctrl_buf;
    msg.msg_controllen = sizeof(ctrl_buf);

    n = recvmsg(sockfd, &msg, 0);
    if (n < 0)
        exit_error("recvmsg (rx)");

    // Extract RX timestamp
    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
        if (cmsg->cmsg_level == SOL_SOCKET && 
            cmsg->cmsg_type == SCM_TIMESTAMPING) {
            struct timespec *times = (struct timespec *)CMSG_DATA(cmsg);
            rx_time = times[0]; // Use software timestamp
            break;
        }
    }

    // Calculate and print duration
    double elapsed = timespec_diff(&tx_time, &rx_time);
    printf("Request-Response time: %.9f seconds\n", elapsed);
    printf("Request fulfilled successfully.\n");

    close(sockfd);
    return 0;
}